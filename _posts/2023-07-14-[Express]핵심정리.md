---
title: "[Express]핵심정리"

toc: true
toc_sticky: true

categories:
  - Express
tags:
  - Express
  - Node.js

last_modified_at: 2023-07-14T14:00:00



---

# Express

=> 이 게시글은 Express를 이용하면 어떻게 간단화되는지 기존 Node.js와 비교하여 설명한다



## 미들웨어

-> 요청과 응답의 중간에 위치하는 것을 미들웨어라고 부르고, app.use와 함께 사용한다  
-> 기본적으로, Node.js의 Express는 **위에서부터 코드를 읽는다는 사실 잊지말자!!!**

### app.use()

---

``` javascript
const express = require('express');
const path = require('path');

const app = express();

app.set('port', process.env.PORT || 3000);

app.use((req, res, next)=>{
    console.log('모든 요청에서 실행됨');
    next();
});

app.get('/', (req, res)=>{
    res.sendFile(path.join(__dirname, 'index.html'));
});

app.get('/about', (req, res)=>{
    res.send('Welcome to Express server');
});

app.listen(app.get('port'), ()=>{
    console.log('express서버가 3000포트에서 실행중~');
});
```

-> 여기서 app.use안에 들어가는 함수가 미들웨어라고 생각하면 되고, 각각의 'app.'으로 구성된 코드를 라우터라고 부른다  
-> app.use()를 이용하여 모든 요청에서 실행되는 코드를 추출할 수 있다  
-> 인자로 실행할 함수가 들어가는데, 함수의 인자로는 기존에 쓰던 request, response 이외에도 다음에 실행할 함수로 next라는 인자가 들어간다. 예를 들어 'localhost:3000/'으로 접근했을시, app.use()실행 후에 app.get('/')를 실행하기 위해서는 next() 작성이 요구된다



### 라우트 매개변수

---

``` javascript
const express = require('express');
const path = require('path');

const app = express();

app.set('port', process.env.PORT || 3000);

app.get('/', (req, res)=>{
    res.sendFile(path.join(__dirname, 'index.html'));
});

app.get('/category/:name', (req, res)=>{
    res.send(`welcome to ${req.params.name}`);
})

app.get('/category/js', (req, res)=>{
    res.send('Welcome to javascript');
});

app.listen(app.get('port'), ()=>{
    console.log('express서버가 3000포트에서 실행중~');
});
```

-> 위의 예시에서 파라미터를 '/:name' 으로 설정해서 name이라는 변수에 여러가지 값을 담을 수 있다. 예를들어 'localhost:3000/category/java'로 접근할 경우, 'welcome to java'가 화면에 뜬다. 'localhost:3000/category/html'로 접근할 경우, 'welcome to html'이 뜨게 된다.  
-> 여기서 name이라는 파라미터값을 req.params.name으로 가져다 쓸 수 있으며, 굳이 name이 아니라 다른 값으로 적어도 된다  
-> 'localhost:3000/category/js'로 접근할 경우, 아래의 get()과 겹치는데, 위에서부터 코드를 읽기 때문에, 상대적으로 위에 있는 코드만 실행된다. 때문에, 라우트 매개변수는 맨아래에서 사용해주는 것이 좋다



### 에러처리 미들웨어

---

-> Express에서 에러를 직접 처리해주지만, 모든 에러를 직접 보여주면 보안상의 문제가 발생할 수 있기 때문에, 개발자가 직접 에러 미들웨어를 만들어주는 것이 권장된다

``` javascript
const express = require('express');
const path = require('path');

const app = express();

app.set('port', process.env.PORT || 3000);

app.get('/', (req, res)=>{
    res.sendFile(path.join(__dirname, 'index.html'));
}, (req, res)=>{
    throw new Error('에러');
});

app.use((req, res, next)=>{
    res.status(404).send('404 에러 Page Not Found');
});

app.use((err, req, res, next)=>{
    console.error(err);
    res.status(500).send(err.message);
});

app.listen(app.get('port'), ()=>{
    console.log('express서버가 3000포트에서 실행중~');
});
```

-> app.use의 함수를 이용하면 에러를 처리하는 미들웨어를 만들 수 있는데, 여기서 주의할 점은 **반드시 error, request, response, next 4개의 인자를 모두 적어주어야 작동**한다는 점이다  
-> 위 예시에서 app.get('/') 로 던져진 에러를 4개의 인자를 가지는 app.use 에러처리 미들웨어에서 받아 처리한다. 여기서 status(500)으로 설정했으므로, HTTP 상태코드는 500으로 뜰 것이다  
-> 추가적으로, app.use를 경로 처리 라우터보다 아래에 놓으면 상위의 라우터에 해당되지 않는 경로요청이 들어올 경우를 처리한다



### response 상세

---

-> Express를 사용하면, 기존 Node.js에서 복잡하게 작성하던 코드를 간단히 작성할 수 있다

``` javascript
// 기존코드
app.get('/', (req, res)=>{
    res.writeHead(200, {'Content-Type':'text/plain;charset=utf-8'});
    res.end('Welcome to Express server');
});

// Express코드
app.get('/', (req, res)=>{
    res.status(200).send('Welcome to Express server');	// status(200) 생략가능
});
```

-> 위쪽이 기존 Node.js에서 사용하던 코드이고, 아래가 Express를 사용하여 간단히 작성한 코드이다



``` javascript
// 기존코드
app.get('/json', (req, res)=>{
    res.writeHead(200, {'Content-Type':'text/plain;charset=utf-8'});
    res.end(JSON.stringify({name:'saemyung'}));
});

// Express코드
app.get('/json', (req, res)=>{
    res.json({name:'saemyung'});
});

```

-> json을 사용할 경우에도 아래와 같이 간단한 코드작성이 가능해졌다



``` javascript
app.get('/', (req, res)=>{
    res.send('Welcome to Express server');
    res.sendFile(path.join(__dirname, 'index.html'));
    res.json({name:'saemyung'});
});
```

-> 위는 세번의 send를 하기 때문에 'Cannot set headers after they are sent to the client'의 오류가 발생하는 코드이다



### next()

---

-> **next는 파라미터에 해당되는 다음 미들웨어/라우터를 실행하는 역할**을 한다

``` javascript
app.use((req, res, next)=>{
    console.log('모든 요청에 실행하고싶어요.');
    next();
});

app.get('/', (req, res)=>{
  	res.send('인덱스 페이지입니다.');
});

app.get('/about', (req, res)=>{
    res.send('Welcome to Express server');
});
```

-> '/about'에 접근할 경우, 먼저 app.use가 실행되고 next()에 의해 '/about'에 해당하는 다음 미들웨어인 app.get('/about')을 실행한다



``` javascript
app.use((req, res, next)=>{
    try{
        console.log(a);		// 여기서 a는 정의되지 않은 변수(에러 발생)
    } catch(err){
        next(err);
    }
});
```

-> 원래 next안에 아무런 인자값을 넣지 않을 경우, 다음 미들웨어가 실행된다. 하지만, next안에 err인자값을 넣을 경우, 다음으로 에러처리 미들웨어가 실행된다



``` javascript
app.get('/', (req, res, next)=>{
    if(true) next('route');
    else next();
}, (req, res)=>{
    console.log('거짓일 경우 실행');
});

app.get('/', (req, res)=>{
    console.log('참일 경우 실행');
});
```

-> next('route')를 이용하면, 다음 라우터를 실행하도록 작동한다. 예를 들어 if문에 의해 true일 경우, next('route')에 의해 다음 라우터인 app.get('/')이 실행되고 false일 경우, next()에 의해 다음 미들웨어인 ' (req, res)=>{ console.log('거짓일 경우 실행')}; '이 작동한다



## Express에서의 Cookie사용 & BodyParser

### Cookie

---

``` javascript
// 기존 Cookie parser
const parseCookies = (cookie = '')=>{
    return cookie
        .split(';')
        .map(e => e.split('='))
        .reduce((acc, [k,v])=>{
            acc[k.trim()] = decodeURIComponent(v);
            return acc;
        }, {});
};
// 기존 Cookie응답
res.writeHead(302, {
            Location: '/',
            'Set-Cookie': `name=${encodeURIComponent(name)}; Expires=${expires.toGMTString()}; HttpOnly; Path=/`,
        });


// Express에서의 Cookie parser와 Cookie응답
const cookieParser = require('cookie-parser');
app.use(cookieParser());

app.get('/', (req, res)=>{
    console.log(req.cookies);		// {myCookie: 'saemyung'}
    res.cookie('name', encodeURIComponent(name), {
        expires: Date.now(),
        httpOnly: true,
        path: '/',
    })
});
```

-> Express에서 제공하는 cookieParser를 require로 가져오면 req.cookies로 쿠키를 가져오는 것이 가능하고, res.cookie() 를 통해 Cookie응답을 처리할 수 있다



### Body Parser

---

``` javascript
// 기존 Body Parser
const key = req.url.split('/')[2];
                let body = '';
                req.on('data', (data)=>{
                    body += data;
                });

                return req.on('end', ()=>{
                    console.log('PUT 본문:', body);
                    users[key] = JSON.parse(body).name;
                    res.writeHead(200, {'Content-Type': 'text/plain; charset=utf-8'});
                    return res.end(JSON.stringify(users));
                });

// Express에서의 Body Parser
app.use(express.json());		// json파싱을 위한 설정
app.use(express.urlencoded({extended: true}));		// HTML form태그에서 받는 data파싱을 위한 설정

app.get('/', (req, res)=>{
    console.log(req.body.(파라미터명);
});
```

-> 클라이언트 측에서 json을 보내는 경우와 HTML의 form태그에서 데이터를 보내는 경우 모두 2개의 app.use 코드를 통해 간단한 처리가 가능하다  
-> 'req.body.(파라미터명)'을 통해 해당 데이터를 가져올 수 있다



## static 미들웨어

-> 특정 작업 처리를 위한 경로를 제외한 HTML, CSS, JS 파일접근 등 나머지 경로를 처리하기 위해 필요한 것이 static 미들웨어이다

``` javascript
// Node.js의 코드
if(req.method === 'GET'){
  if(req.url === '/'){
      const data = await fs.readFile('./4장/2/restFront.html');
      res.writeHead(200, {'Content-Type': 'text/html; charset=utf-8'});
      return res.end(data);
  } 
  // 기존 static 처리
  try{
      const data = await fs.readFile(path.join(__dirname, req.url));
      return res.end(data);
  } catch(err){
  }
}

// Express의 static 미들웨어
app.use('/', express.static(__dirname, '실제 파일경로'));

```

-> 기존 Node.js에서 try-catch문을 이용하여 static처리하던 것을 express.static 키워드를 사용하여 처리한다  
-> 예를 들어 'localhost:8080/index.html'로 요청이 오면, '__dirname + 실제 파일경로'로 해석하여 해당 경로에서 파일을 가져와 띄워주는 식으로 작동한다고 생각하면 된다  
-> 여러가지 app.use를 사용할 경우, 이 static의 app.use를 어디에 놓는지에 따라 효율적인 코드작성이 가능하다. 예를 들어, static 미들웨어 작동시에 cookie, body parser등이 필요하지 않다면 해당 app.use 코드보다 위에 static 미들웨어에 관한 app.use를 적는 것이 효율적일 것이다