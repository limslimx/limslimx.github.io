---
title: "[JS] JS의 심화문법 정리"

toc: true
toc_sticky: true

categories:
  - JS
tags:
  - JS
  - Language

last_modified_at: 2023-07-01T21:40:00
---

# JavaScript 심화문법 정리

## 변수

### 호이스팅

---

-> scope 내부 어디서든 변수의 선언은 최상위에서 선언된 것처럼 작동하는 방식을 의미한다  
-> 호이스팅은 var, const, let 모두에게 적용되는 방식이다

```
console.log(name);      // undefined 출력

var name = "saemyung";
```

```
console.log(name);      // 오류 발생

const name = "saemyung";        // let으로 지정해도 마찬가지
```

-> 위의 2가지에서 볼 수 있듯이, var와 달리 const와 let의 경우 Temporal Dead Zone 즉, 변수할당 전에는 사용할 수 없다

cf>Temporal Dead Zone  
-> 위의 코드처럼 변수선언 및 초기화 이전의 상태  
-> var는 const, let과 달리 Temporal Dead Zone의 영향을 받지 않아 변수할당 전에도 사용할 수 있다  
-> 이는 오류발생의 원인이기 때문에 var사용을 피한다

### 변수지정어에 따른 변수의 생성과정

---

1. var
   -> '선언 및 초기화' 단계와 '할당' 단계 2가지로 구분(초기화 단계는 undefined를 할당하는 단계)  
   -> 그렇기 때문에 값을 할당하기 전에 호출해도 undefined라는 값이 출력된다

2. let  
   -> '선언' 단계, '초기화' 단계, '할당' 단계 3가지로 구분  
   -> 호이스팅되며 선언 단계가 일어나지만, 초기화 단계는 해당 코드에 도달했을때 발생하기 때문에 Temporal Dead Zone에서 해당 변수 접근 시 reference오류 발생

3. const
   -> '선언, 초기화 및 할당' 단계가 한꺼번에 발생  
   -> var, let과 달리 선언만 하고 할당을 나중에 하는 것이 불가능

+α> scope  
-> block-scoped와 function-scoped 2가지로 나눠진다  
-> block-scoped는 function, if문, for문, switch문 등 각 block안에서 선언된 변수는 해당 block내부에서 밖에 사용할 수 없는 방식으로 const, let이 이에 포함된다  
-> function-scoped는 blocked-scoped와 달리 function을 제외한 if문, for문, switch문 등의 block안에서 선언된 변수들은 외부에서도 사용가능한 방식으로 var가 이에 해당한다

## 객체 관련

### 생성자 함수

---

-> 수많은 객체를 만들기 쉽도록 도와주는 함수

```
function User(name,age){
    this.name = name;
    this.age = age;
    this.sayName = function(){
         console.log(this.name);
    }
}

let user1 = new User('a', 20);
let user2 = new User('b', 21);
let user3 = new User('c', 22);
```

-> 생성자 함수의 함수명 첫글자는 대문자로 설정하는 것이 관례(일반함수와 구분위함)  
-> 생성자 함수를 사용하려면 반드시 new를 사용해야함  
-> this라는 객체를 만들고 객체내부에 name과 age라는 property를 만든후 값을 할당하여 this를 반환하는 과정이라 생각하면됨

### Computed property

---

```
function getObj(key, val){
    return {
        [key]: val
    }
};

console.log(test('name', 'lim'));      // { name: 'saemyung' } 출력
```

-> 변수에 저장된 값을 객체의 property로 이용할 수 있는 방식  
-> 위의 코드를 통해 name property값이 lim인 객체를 반환받음

### 객체 메서드

---

1. Object.assign(): 객체 복사

```
const lim = {
    name: 'saemyung',
    age: 23,
};

const lim2 = {
    weight: 70,
};

const lim3 = Object.assign({height: 180}, lim, lim2);
```

-> lim3은 lim, lim2의 property에 height를 추가한 객체를 property로 가지는 객체로 생성됨

2. Object.keys(): 객체 property의 key값들을 배열로 반환
3. Object.values(): 객체 property의 value값들을 배열로 반환
4. Object.entries(): 객체 property의 key,value값들을 묶어 배열로 반환

### Symbol

---

-> 객체의 property key값을 고유하게 설정함으로써 key값의 유일성을 보장해준다  
-> Symbol()을 통해 생성하고, 이때 인자로 값을 넘길 수 있는데, 이는 디버깅 시에 어떤 값인지 확인하기 용이하도록 돕는다  
-> Symbol()을 통해 생성된 값은 항상 다르므로 유일성이 보장된다  
-> Symbol.for()을 이용하여 생성한 전역Symbol은 하나의 Symbol만을 생성하여 공유한다

```
const id = Symbol('id');

const user = {
    name: 'lim',
    age: 23,
    [id]: 'myId',
};

console.log(user[id]);     // myId 출력
```

-> 위의 코드는 객체의 key로써 Symbol을 사용한 예시이다  
-> Object.keys(), entries() 등의 객체 메서드를 사용해도 Symbol은 드러나지 않는다  
-> Object.getOwnPropertySymbols(객체명)을 이용하여 Symbol을 확인할 수 있다

```
const user = {
    name: 'lim',
    age: 23,
};

const showName = Symbol('show name');
user[showName] = function(){
    console.log(this.name);
}

user[showName]();

for (let key in user){
    console.log(`His ${key} is ${user[key]}`);
}
```

-> 위처럼 겉으로는 드러나지 않으면서 객체의 key값으로 존재할 수 있다

## JS 내장 메서드

### map

---

-> 배열.map((요소, 인덱스, 배열) => { return 요소; }); 의 형태로 사용한다  
-> map의 결과로 나오는 배열은 기존의 배열을 수정하지 않고 새로 만들어진 배열이다

```
let userList = [
    {name: 'mike', age:30},
    {name: 'tom', age:10},
    {name: 'jane', age:27}
];

let userValidList = userList.map((elem, idx) => {
    return Object.assign({}, elem, {id: idx+1 ,ageValid: elem.age>20});
});

console.log(userList === userValidList);        // false

console.log(userValidList);
//  { name: 'mike', age: 30, id: 1, ageValid: true },
    { name: 'tom', age: 10, id: 2, ageValid: false },
    { name: 'jane', age: 27, id: 3, ageValid: true }
```

-> Object.assign() 메서드를 이용하여 기존 객체에 다른 property값 추가  
-> map() 메서드를 통해 새로만든 userValidList는 userList와는 다른 배열임

### reduce

---

-> 배열.reduce((누적값, 현재값, 인덱스, 요소) => { return 결과; }, 초기값); 의 형태로 사용한다. 초기값을 적지 않을 경우 해당배열의 0번째 인덱스 요소값이 자동으로 초기값으로 설정된다

```
const arr = [1,3,5];

const result = arr.reduce((prev, curr) => {
    return prev+curr;
});

console.log(result);        // 9
```

-> 위는 덧셈의 결과를 저장하는 함수의 예시이다

```
let userList = [
    {name: 'mike', age:30},
    {name: 'tom', age:10},
    {name: 'jane', age:27}
];

let userValidList = userList.reduce((prev, curr, idx, arr) => {
    prev.push(Object.assign({}, curr, {id: idx+1, ageValid: curr.age>20}));
    return prev;
}, []);

console.log(userList === userValidList);        // false

console.log(userValidList);
```

-> reduce() 메서드를 이용하여 위의 map() 메서드와 같은 결과를 도출함  
-> 이처럼 reduce() 메서드를 이용하면 sort, filter, every, some, find, findIndex, includes 메서드를 모두 구현가능함
