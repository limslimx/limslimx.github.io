---
title: "[JS] JS의 심화문법 정리"

toc: true
toc_sticky: true

categories:
  - JS
tags:
  - JS
  - Language

last_modified_at: 2023-07-01T21:40:00
---

# JavaScript 심화문법 정리

## 변수

### 호이스팅

---

-> scope 내부 어디서든 변수의 선언은 최상위에서 선언된 것처럼 작동하는 방식을 의미한다  
-> 호이스팅은 var, const, let 모두에게 적용되는 방식이다

```
console.log(name);      // undefined 출력

var name = "saemyung";
```

```
console.log(name);      // 오류 발생

const name = "saemyung";        // let으로 지정해도 마찬가지
```

-> 위의 2가지에서 볼 수 있듯이, var와 달리 const와 let의 경우 Temporal Dead Zone 즉, 변수할당 전에는 사용할 수 없다

cf>Temporal Dead Zone  
-> 위의 코드처럼 변수선언 및 초기화 이전의 상태  
-> var는 const, let과 달리 Temporal Dead Zone의 영향을 받지 않아 변수할당 전에도 사용할 수 있다  
-> 이는 오류발생의 원인이기 때문에 var사용을 피한다

### 변수지정어에 따른 변수의 생성과정

---

1. var
   -> '선언 및 초기화' 단계와 '할당' 단계 2가지로 구분(초기화 단계는 undefined를 할당하는 단계)  
   -> 그렇기 때문에 값을 할당하기 전에 호출해도 undefined라는 값이 출력된다

2. let  
   -> '선언' 단계, '초기화' 단계, '할당' 단계 3가지로 구분  
   -> 호이스팅되며 선언 단계가 일어나지만, 초기화 단계는 해당 코드에 도달했을때 발생하기 때문에 Temporal Dead Zone에서 해당 변수 접근 시 reference오류 발생

3. const
   -> '선언, 초기화 및 할당' 단계가 한꺼번에 발생  
   -> var, let과 달리 선언만 하고 할당을 나중에 하는 것이 불가능

+α> scope  
-> block-scoped와 function-scoped 2가지로 나눠진다  
-> block-scoped는 function, if문, for문, switch문 등 각 block안에서 선언된 변수는 해당 block내부에서 밖에 사용할 수 없는 방식으로 const, let이 이에 포함된다  
-> function-scoped는 blocked-scoped와 달리 function을 제외한 if문, for문, switch문 등의 block안에서 선언된 변수들은 외부에서도 사용가능한 방식으로 var가 이에 해당한다

## 객체 관련

### 생성자 함수

---

-> 수많은 객체를 만들기 쉽도록 도와주는 함수

```
function User(name,age){
    this.name = name;
    this.age = age;
    this.sayName = function(){
         console.log(this.name);
    }
}

let user1 = new User('a', 20);
let user2 = new User('b', 21);
let user3 = new User('c', 22);
```

-> 생성자 함수의 함수명 첫글자는 대문자로 설정하는 것이 관례(일반함수와 구분위함)  
-> 생성자 함수를 사용하려면 반드시 new를 사용해야함  
-> this라는 객체를 만들고 객체내부에 name과 age라는 property를 만든후 값을 할당하여 this를 반환하는 과정이라 생각하면됨

### Computed property

---

```
function getObj(key, val){
    return {
        [key]: val
    }
};

console.log(test('name', 'lim'));      // { name: 'saemyung' } 출력
```

-> 변수에 저장된 값을 객체의 property로 이용할 수 있는 방식  
-> 위의 코드를 통해 name property값이 lim인 객체를 반환받음

### 객체 메서드

---

1. Object.assign(): 객체 복사

```
const lim = {
    name: 'saemyung',
    age: 23,
};

const lim2 = {
    weight: 70,
};

const lim3 = Object.assign({height: 180}, lim, lim2);
```

-> lim3은 lim, lim2의 property에 height를 추가한 객체를 property로 가지는 객체로 생성됨

2. Object.keys(): 객체 property의 key값들을 배열로 반환
3. Object.values(): 객체 property의 value값들을 배열로 반환
4. Object.entries(): 객체 property의 key,value값들을 묶어 배열로 반환

### Symbol

---

-> 객체의 property key값을 고유하게 설정함으로써 key값의 유일성을 보장해준다  
-> Symbol()을 통해 생성하고, 이때 인자로 값을 넘길 수 있는데, 이는 디버깅 시에 어떤 값인지 확인하기 용이하도록 돕는다  
-> Symbol()을 통해 생성된 값은 항상 다르므로 유일성이 보장된다  
-> Symbol.for()을 이용하여 생성한 전역Symbol은 하나의 Symbol만을 생성하여 공유한다

```
const id = Symbol('id');

const user = {
    name: 'lim',
    age: 23,
    [id]: 'myId',
};

console.log(user[id]);     // myId 출력
```

-> 위의 코드는 객체의 key로써 Symbol을 사용한 예시이다  
-> Object.keys(), entries() 등의 객체 메서드를 사용해도 Symbol은 드러나지 않는다  
-> Object.getOwnPropertySymbols(객체명)을 이용하여 Symbol을 확인할 수 있다

```
const user = {
    name: 'lim',
    age: 23,
};

const showName = Symbol('show name');
user[showName] = function(){
    console.log(this.name);
}

user[showName]();

for (let key in user){
    console.log(`His ${key} is ${user[key]}`);
}
```

-> 위처럼 겉으로는 드러나지 않으면서 객체의 key값으로 존재할 수 있다

### Property Attribute

---

-> 객체의 각 property에는 value말고도 writable, enumerable, configurable이라는 attribute를 가진다

1. value: 실제 property의 값
2. writable: 해당 property값을 수정할 수 있는지의 여부
3. enumerable: 열거가 가능한지의 여부(반복문, consol.log등을 통해 해당 property가 나열되는지)
4. configurable
   -> 상위 3가지 property attribute값들을 변경할 수 있는지의 여부
   -> 단, writable을 true에서 false로 변경하는 경우와 writable이 true일 경우 value를 변경하는 것은 가능하다

``` javascript
const lim = {
    name: 'saemyung',
    age: 23,
};

console.log(Object.getOwnPropertyDescriptors(lim));

Object.defineProperty(lim, 'name', {
    value: 'lim',
    writable: false,
    enumerable: false,
    configurable: false
});

console.log(Object.getOwnPropertyDescriptor(lim, 'name'));
lim.name = "saemyung";		// 수정불가(오류는 발생하지 않음)
console.log(lim);		// { age: 23 }
```

-> Object.getOwnPropertyDescriptor(인스턴스명, 프로퍼티명)을 통해 하나의 property attribute값을 확인할 수 있고, Object.getOwnPropertyDescriptors(인스턴스명)을 통해 모든 property attribute값을 확인가능하다
-> Object.defineProperty(인스턴스명, 프로퍼티명, 수정사항객체)를 통해 property attribute를 설정
-> 위의 예시에서는 name property의 writable이 false이기 때문에 value값이 수정불가하고, configurable이 false이기 때문에 마지막줄 console.log에서도 name property가 출력되지 않는다



### 불변객체

---

1. extensible
   ``` javascript
   const lim = {
       name: 'saemyung',
       age: 23,
   };
   
   console.log(Object.isExtensible(lim));		// true
   Object.preventExtensions(lim);
   console.log(Object.isExtensible(lim));		// false
   
   lim.height = 170;
   console.log(lim);		{ name: 'saemyung', age: 23 }
   
   delete lim.age;
   console.log(lim);		{ name: 'saemyung' }
   ```

   -> Object.isExtensible(인스턴스명)은 default값이 true(기본적으로 property 추가가 가능)
   -> Object.preventExtensions(인스턴스명)로 해당객체에 property 추가하는 것을 막을 수 있음
   -> 추가하는 것이 안될뿐 delete를 통한 삭제는 가능함

   

2. Seal
   -> property attribute 중 configurable 값이 false이고, 별도의 property 추가 및 삭제가 불가능하도록 만든 것과 같음

   ``` javascript
   const lim = {
       name: 'saemyung',
       age: 23,
   };
   
   console.log(Object.isSealed(lim));		// false
   Object.seal(lim);
   console.log(Object.isSealed(lim));		// true
   
   lim.height = 170;
   console.log(lim);		// { name: 'saemyung', age: 23 }
   
   delete lim.age;
   console.log(lim);		// { name: 'saemyung', age: 23 }
   ```

   -> Object.seal(인스턴스명)을 통해 해당 객체를 seal 할 수 있다
   -> 원래 있던 property의 value 값 변경은 가능하지만, 별도의 property 추가 및 삭제가 불가능하다
   -> configurable값이 false인 것과 같기 때문에 예외(property attribute 설명쪽에 나와있는 2가지 예외)를 제외하면 Object.defineProperty()를 통해 property attribute를 변경하는 것이 불가능하다

   

3. Freezed
   -> read 외의 모든 기능을 막는것
   -> Seal에서 property attribute 중 writable 까지 false된 것이라고 생각하면 됨

   ``` javascript
   const lim = {
       name: 'saemyung',
       age: 23,
   };
   
   console.log(Object.isFrozen(lim));		// false
   Object.freeze(lim);
   console.log(Object.isFrozen(lim));		// true
   
   lim.height = 170;
   console.log(lim);		// { name: 'saemyung', age: 23 }
   
   delete lim.age;
   console.log(lim);		// { name: 'saemyung', age: 23 }
   ```

   -> Object.freeze(인스턴스명)을 통해 해당 객체를 freeze할 수 있다

   -> 별도의 property 추가 및 삭제가 불가능할 뿐만 아니라, 원래 있던 property의 value값 변경 역시 불가능하다
   -> property attribute 중 writable과 configurable이 false이기 때문에 모든 property attribute 값을 변경하는 것이 불가능하다

+α) 객체 안의 객체의 경우

``` javascript
const lim = {
    name: 'saemyung',
    age: 23,
  	lim2: {
      name: 'sammyung',
      age: 32
    },
};

Object.freeze(lim);
console.log(Object.isFrozen(lim));		// true
console.log(Object.isFrozen(lim.lim2));		// false
```

-> 어떤 객체를 freeze 시켜도 그 객체 내부의 객체는 freeze되지 않음을 알 수 있다
-> 이는 freeze 뿐만 아니라 extensible, seal에서도 동일하다



## JS 내장 메서드

### map

---

-> 배열.map((요소, 인덱스, 배열) => { return 요소; }); 의 형태로 사용한다  
-> map의 결과로 나오는 배열은 기존의 배열을 수정하지 않고 새로 만들어진 배열이다

```
let userList = [
    {name: 'mike', age:30},
    {name: 'tom', age:10},
    {name: 'jane', age:27}
];

let userValidList = userList.map((elem, idx) => {
    return Object.assign({}, elem, {id: idx+1 ,ageValid: elem.age>20});
});

console.log(userList === userValidList);        // false

console.log(userValidList);
//  { name: 'mike', age: 30, id: 1, ageValid: true },
    { name: 'tom', age: 10, id: 2, ageValid: false },
    { name: 'jane', age: 27, id: 3, ageValid: true }
```

-> Object.assign() 메서드를 이용하여 기존 객체에 다른 property값 추가  
-> map() 메서드를 통해 새로만든 userValidList는 userList와는 다른 배열임

### reduce

---

-> 배열.reduce((누적값, 현재값, 인덱스, 요소) => { return 결과; }, 초기값); 의 형태로 사용한다. 초기값을 적지 않을 경우 해당배열의 0번째 인덱스 요소값이 자동으로 초기값으로 설정된다

```
const arr = [1,3,5];

const result = arr.reduce((prev, curr) => {
    return prev+curr;
});

console.log(result);        // 9
```

-> 위는 덧셈의 결과를 저장하는 함수의 예시이다

```
let userList = [
    {name: 'mike', age:30},
    {name: 'tom', age:10},
    {name: 'jane', age:27}
];

let userValidList = userList.reduce((prev, curr, idx, arr) => {
    prev.push(Object.assign({}, curr, {id: idx+1, ageValid: curr.age>20}));
    return prev;
}, []);

console.log(userList === userValidList);        // false

console.log(userValidList);
```

-> reduce() 메서드를 이용하여 위의 map() 메서드와 같은 결과를 도출함  
-> 이처럼 reduce() 메서드를 이용하면 sort, filter, every, some, find, findIndex, includes 메서드를 모두 구현가능함

## 구조분해

-> 배열 및 객체 구조분해를 이용하면 값변경이 용이하다. 실제로 두 변수의 값을 바꾸려면 또다른 하나의 변수를 선언해야하지만 구조분해를 이용하면 이런 과정없이 해결가능하다

```
let n1=1, n2=2;
[n1,n2] = [n2,n1];
```

-> 위의 방식으로 n1과 n2의 값을 바꿀 수 있다

```
let user = {
    name: 'lim',
    age:23,
};

let {name, age} = user;
console.log(name);      // lim
console.log(age);       // 23
```

-> name과 age 각각의 변수값에 user.name과 user.age의 값이 들어간다

## 나머지 매개변수 & 전개구문

### 나머지 매개변수

---

-> 함수로 인자값이 여러개 들어올 경우 일일이 적는 것을 대체하기 위해 ES6에서는 나머지 매개변수라는 방법을 도입했다  
-> 나머지 매개변수에는 배열의 형태로 들어간다

```
function User(name, age, ...skills){
    this.name = name;
    this.age = age;
    this.skills = skills;
}

const user1 = new User('lim', 23, 'js', 'ts', 'node');
const user2 = new User('kim', 33, 'java', 'spring');
const user3 = new User('park', 43, 'python', 'django', 'flask');

console.log(user1);
console.log(user2);
console.log(user3);
```

-> 생성자로 많은 인수를 받아야할때 나머지 매개변수를 이용하면 간단히 표현이 가능하다

### 전개구문

---

-> 전개구문을 사용한 손쉬운 배열, 객체 복사가 가능하다  
-> 여기서 복사라고 표현한 이유는 전개구문을 통해 생성된 배열 or 객체는 기존의 것과 별개로 새로 만들어진 배열 or 객체이다

```
const arr = [1,2,3];
const arr2 = [...arr];
console.log(arr2);      // [1,2,3]
console.log(arr===arr2);        // false

const obj = {name:'lim', age:23};
const obj2 = {...obj};
console.log(obj2);      // { name: 'lim', age: 23 }
console.log(obj===obj2);        // false
```

-> 전개구문을 통해 새로 만든 배열 or 객체는 기존의 배열 or 객체와 다르다

```
let user = {name: 'lim'};
let info = {age: 23};
let fe = ['js', 'node'];
let lang = ['kor', 'eng'];

let obj = Object.assign({},
    user, info,
    {skills: []}
);

fe.forEach((elem) => {
    obj.skills.push(elem);
});
lang.forEach((elem) => {
    obj.skills.push(elem);
});

console.log(obj);
// { name: 'lim', age: 23, skills: [ 'js', 'node', 'kor', 'eng' ] }
```

```
let user = {name: 'lim'};
let info = {age: 23};
let fe = ['js', 'node'];
let lang = ['kor', 'eng'];

let obj = {...user, ...info, skills: [...fe, ...lang]};

console.log(obj);
// { name: 'lim', age: 23, skills: [ 'js', 'node', 'kor', 'eng' ] }
```

-> 2가지 코드 중 위의 것이 전개구문을 사용하지 않고 복사한 경우이고, 아래가 전개구문을 사용하여 복사한 경우인데, 훨씬 효율적인 코드로 바뀌었음을 알 수 있다



## 프로토타입

---

-> 프로토타입 객체는 원형을 의미한다
-> 같은 생성자로부터 만들어진 객체들은 같은 프로토타입 객체를 공유한다
-> 메서드를 만들때, '인스턴스.메서드'의 방식보다 프로토타입을 이용하는 방식이 더 효율적이다(프로토타입을 통해 만들어놓으면, 굳이 각각의 인스턴스에서 만들 필요가 없기 때문)

``` javascript
function Person(name, age){
  	this.name = name;
  	this.age = age;
}

const lim = new Person('saemyung', 23);

const p1 = new Person.prototype.constructor('proto1', 10);
const p2 = new lim.constructor('proto2', 20);
const p3 = new lim.__proto__.constructor('proto3', 30);
const p4 = new Object.getPrototypeOf(lim).constructor('proto4', 40);

console.log(Person.prototype.constructor===Person);		// true
```

-> 위의 코드처럼 4가지 방식을 통해 동일한 프로토타입 설계가 가능하다
-> .prototype.constructor을 적용하면 원래의 생성자와 같아진다
